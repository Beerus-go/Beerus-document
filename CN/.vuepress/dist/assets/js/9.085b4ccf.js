(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{395:function(t,e,s){"use strict";s.r(e);var a=s(54),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"session原理介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#session原理介绍"}},[t._v("#")]),t._v(" Session原理介绍")]),t._v(" "),s("p",[t._v("里面用到了两个技术，一个是AES加密，一个是JSON")]),t._v(" "),s("h2",{attrs:{id:"生成token的原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生成token的原理"}},[t._v("#")]),t._v(" 生成token的原理")]),t._v(" "),s("ul",[s("li",[t._v("当调用 session.CreateToken函数时，函数内部会将参数转化成 JSON字符串，然后在后面拼接上一个最后有效时间")]),t._v(" "),s("li",[t._v("将上一步 得到的字符串进行AES加密，并转成base64返回")])]),t._v(" "),s("h2",{attrs:{id:"还原token的原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#还原token的原理"}},[t._v("#")]),t._v(" 还原token的原理")]),t._v(" "),s("ul",[s("li",[t._v("当调用 session.RestoreToken函数时，函数内部会将token进行base64解码，得到一个[]byte类型的加密数据")]),t._v(" "),s("li",[t._v("将上一步 得到的加密数据 进行AES解密，就会得到最开始的JSON串+最后有效时间")]),t._v(" "),s("li",[t._v("切割上一步的 字符串得到一个JSON串 和 一个时间戳，判断当前时间戳 是否大于 这个时间戳，如果大于就说明已经失效了，直接返回提示信息即可")]),t._v(" "),s("li",[t._v("如果小于这个时间戳，那么将JSON串 转化成 struct")])]),t._v(" "),s("h2",{attrs:{id:"有效期原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有效期原理"}},[t._v("#")]),t._v(" 有效期原理")]),t._v(" "),s("ul",[s("li",[t._v("加密的时候 将Timeout+当前时间戳，得到一个结果，将结果拼接到JSON后面")]),t._v(" "),s("li",[t._v("解密之前，判断 上一步拼在后面的时间戳 是否 大于当前时间戳")])]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/beerus/"}},[t._v("返回刚才的文档")])],1)])}),[],!1,null,null,null);e.default=r.exports}}]);